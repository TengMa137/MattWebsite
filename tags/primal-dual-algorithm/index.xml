<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Primal-Dual Algorithm on Welcome</title>
    <link>http://localhost:1313/tags/primal-dual-algorithm/</link>
    <description>Recent content in Primal-Dual Algorithm on Welcome</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 30 Aug 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/primal-dual-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hungarian Algorithm in multiple object tracking</title>
      <link>http://localhost:1313/posts/2024-8-30-km/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024-8-30-km/</guid>
      <description>&lt;p&gt;Facilitated by the development of deep learning in subfields of computer vision including single object tracking (SOT), video object detection (VOD), and re-identification (Re-ID), many methods of multi-object tracking (MOT) have emerged, such as various embedding models designed for object locations and track identities [1]. While tracking-by-detection is still an effective paradigm for MOT, since we can always combine off-the-shelf state-of-the-art detectors and Re-ID models to improve the MOT system. The idea is: detect the objects in the current frame, then try to associate the detected boxes with tracked boxes in the previous frames. In practice, we need a more sophisticated design (e.g. choose similarity indices for data association, use Kalman Filter to predict new locations of tracks etc.) and proper strategies (e.g. to delete or initialize tracks). Hunarian algorithm is commonly used to matching objects after we get the similarity matrix, in this blog, I will try to explain how and why Hunarian algorithm works from the perspective of linear programming.&lt;br&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
